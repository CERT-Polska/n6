# Copyright (c) 2019-2025 NASK. All rights reserved.

import re
from collections.abc import (
    Callable,
    Mapping,
)
from typing import Optional

from n6brokerauthapi.auth_base import (
    BaseBrokerAuthManagerMaker,
    BaseBrokerAuthManager,
)
from n6lib.api_key_auth_helper import (
    APIKeyAuthError,
    APIKeyAuthHelper,
)
from n6lib.auth_db import models
from n6lib.config import (
    ConfigError,
    ConfigMixin,
)
from n6lib.context_helpers import ThreadLocalNamespace
from n6lib.log_helpers import get_logger
from n6lib.typing_helpers import KwargsDict


LOGGER = get_logger(__name__)


class StreamApiBrokerAuthManagerMaker(ConfigMixin, BaseBrokerAuthManagerMaker):

    config_spec = """
        [stream_api_broker_auth]

        # Important: the value of the following option in the
        # configuration file has to be identical to the value
        # of the `api_key_based_auth.server_secret` option in
        # the *n6* Portal API's configuration. If not, users
        # will be unable to authenticate to *n6* Stream API
        # with any API keys obtained/generated via *n6* Portal).
        #
        # *** Remember to provide a **secure** secret value *** 
        # ***   of this option in your configuration file!  ***
        server_secret :: str

        push_exchange_name = _push :: str
        autogenerated_queue_prefix = stomp :: str
    """

    def __init__(self, settings):
        super().__init__(settings=settings)
        self._config = self.get_config_section(settings)
        self._thread_local = ThreadLocalNamespace(attr_factories={
            'autogenerated_queue_matcher': self._make_autogenerated_queue_matcher,
        })
        self._verify_server_secret_is_not_blank()

    def _make_autogenerated_queue_matcher(self) -> Callable[[str], Optional[re.Match]]:
        prefix = self._config['autogenerated_queue_prefix']
        if prefix:
            regex = re.compile(rf'\A({re.escape(prefix)}.*)\Z')
            return regex.search
        return lambda _: None

    def _verify_server_secret_is_not_blank(self):
        if not self._config['server_secret'].strip():
            raise ConfigError(
                'The `stream_api_broker_auth.server_secret` '
                'option needs to be set to a non-empty and '
                'non-whitespace-only value)')

    def get_manager_factory(self, params: Mapping[str, str], /,
                            need_authentication: bool,
                            ) -> Callable[..., 'StreamApiBrokerAuthManager']:
        return StreamApiBrokerAuthManager

    def get_manager_factory_kwargs(self, params: Mapping[str, str], /,
                                   need_authentication: bool,
                                   ) -> KwargsDict:
        base = super().get_manager_factory_kwargs(params, need_authentication)
        return dict(base,
                    push_exchange_name=self._config['push_exchange_name'] or None,
                    autogenerated_queue_matcher=self._thread_local.autogenerated_queue_matcher,
                    server_secret=self._config['server_secret'])


class StreamApiBrokerAuthManager(BaseBrokerAuthManager):

    def __init__(self, *,
                 push_exchange_name: Optional[str],
                 autogenerated_queue_matcher: Callable[[str], Optional[re.Match]],
                 server_secret: str,
                 **kwargs):
        self._push_exchange_name = push_exchange_name
        self._autogenerated_queue_matcher = autogenerated_queue_matcher
        self._server_secret = server_secret
        self._api_key_auth_helper = None
        super().__init__(**kwargs)


    def __enter__(self) -> 'BaseBrokerAuthManager':
        self._api_key_auth_helper = APIKeyAuthHelper(
            self._server_secret,
            self._authenticate_with_user_id_and_api_key_id)
        try:
            return super().__enter__()
        except:
            self._api_key_auth_helper = None
            raise

    def __exit__(self, exc_type, exc_val, exc_tb) -> None:
        try:
            return super().__exit__(exc_type, exc_val, exc_tb)
        finally:
            self._api_key_auth_helper = None

    def _authenticate_with_user_id_and_api_key_id(self, user_id: str, api_key_id: str,
                                                  ) -> Optional[models.User]:
        assert self.db_session is not None
        return self.db_session.query(models.User).filter(
            # Note: here we do *not* check the `is_blocked` flag because
            # `BaseBrokerAuthManager._verify_and_get_non_blocked_user_obj()`
            # will check it.
            models.User.login == user_id,
            models.User.api_key_id == api_key_id,
        ).one_or_none()


    EXPLICITLY_ILLEGAL_USERNAMES = ('', 'guest')

    def should_try_to_verify_user(self) -> bool:
        if self.broker_username in self.EXPLICITLY_ILLEGAL_USERNAMES:
            LOGGER.error(
                'The %a username is explicitly considered illegal!',
                self.broker_username)
            return False
        return super().should_try_to_verify_user()


    def verify_and_get_user_obj(self, need_authentication: bool) -> Optional[models.User]:
        if need_authentication:
            user_obj = self._fetch_user_obj_authenticated()
        else:
            user_obj = self._fetch_user_obj()
        if user_obj is not None:
            org_obj = user_obj.org
            assert org_obj is not None   # (guaranteed because `User.org_id` is not nullable)
        # Note: here we do *not* check the `is_blocked` flag because
        # `BaseBrokerAuthManager._verify_and_get_non_blocked_user_obj()`
        # (which calls this method) will check it.
        return user_obj

    def _fetch_user_obj_authenticated(self) -> Optional[models.User]:
        assert self.db_session is not None
        assert self._api_key_auth_helper is not None
        try:
            user_obj = self._api_key_auth_helper.authenticate_with_api_key(api_key=self.password)
        except APIKeyAuthError:
            user_obj = None
        if user_obj is not None:
            assert isinstance(user_obj, models.User)
            if user_obj.login == self.broker_username:
                return user_obj
        LOGGER.warning('Failed to authenticate the user %a.', self.broker_username)
        return None

    def _fetch_user_obj(self) -> Optional[models.User]:
        assert self.db_session is not None
        return self.db_session.query(models.User).filter(
            models.User.login == self.broker_username).one_or_none()


    def apply_vhost_rules(self) -> bool:
        # maybe TODO later: wouldn't it be nice to be able to specify allowed vhosts in config?
        return self.user_verified

    def apply_exchange_rules(self) -> bool:
        # refuse access if user is not verified; otherwise:
        # never give the "configure" permission; "write" only
        # to a certain common exchange; "read" only from an
        # exchange whose name is the user's organisation ID
        if not self.user_verified:
            return False
        exchange_name = self.res_name
        assert exchange_name is not None   # (guaranteed thanks to view's `validate_params()`...)
        if self.permission_level == 'configure':
            return False
        if (self.permission_level == 'write'
                and self._push_exchange_name is not None
                and exchange_name == self._push_exchange_name):
            return True
        if (self.permission_level == 'read'
                and self.user_obj.org is not None
                and self.user_obj.org.org_id == exchange_name):
            return True
        return False

    def apply_queue_rules(self) -> bool:
        # refuse access if user is not verified; otherwise:
        # grant all permissions for autogenerated queues
        # (these are user-created queues, whose names are
        # auto-generated by the broker; unknown to other users)
        if not self.user_verified:
            return False
        queue_name = self.res_name
        assert queue_name is not None   # (guaranteed thanks to view's `validate_params()`...)
        return (self._autogenerated_queue_matcher(queue_name) is not None)

    def apply_topic_rules(self) -> bool:
        # note that *topic_path* is queried only if *resource_path*
        # has given an "allow..." response
        return self.user_verified
